#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "structures.h"
#include "poscar_writer.h"

#define M_PI 3.14159265358979323846

int get_atomic_number(const char *symbol) {
    for (unsigned int i = 0; i < sizeof(periodic_table) / sizeof(periodic_table[0]); i++) {
        if (strncmp(symbol, periodic_table[i].symbol, 2) == 0) {
            return periodic_table[i].atomic_number;
        }
    }
    return -1;
}

int compare_atoms(const void *a, const void *b, int ascending) {
    int num_a = get_atomic_number(((Atom *)a)->element);
    int num_b = get_atomic_number(((Atom *)b)->element);
    return ascending ? (num_a - num_b) : (num_b - num_a);
}

int compare_atoms_asc(const void *a, const void *b) {
    return compare_atoms(a, b, 1);
}

int compare_atoms_desc(const void *a, const void *b) {
    return compare_atoms(a, b, 0);
}

void sort_atoms_custom(char **custom_order, int custom_count) {
    Atom *sorted_atoms = malloc(sizeof(Atom) * structure.atom_count);
    int index = 0;

    for (int i = 0; i < custom_count; i++) {
        for (int j = 0; j < structure.atom_count; j++) {
            if (strncmp(structure.atoms[j].element, custom_order[i], 2) == 0) {
                sorted_atoms[index++] = structure.atoms[j];
            }
        }
    }

    memcpy(structure.atoms, sorted_atoms, sizeof(Atom) * structure.atom_count);
    free(sorted_atoms);
}

void write_poscar(const char *filename, int sort_option, char **custom_order, int custom_count) {
    FILE *file = fopen(filename, "w");
    if (!file) {
        fprintf(stderr, "Error opening file for writing!\n");
        return;
    }

    int field_width = 20;

    fprintf(file, "POSCAR file generated by CrystalShift\n");
    fprintf(file, "1.0\n");

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            fprintf(file, "%*.*f ", field_width, 15, structure.lattice[i][j]);
        }
        fprintf(file, "\n");
    }

    Structure output_structure = structure;
    Structure normalized_structure_poscar = create_normalized_structure(&structure);

    if (check_for_duplicates(&normalized_structure_poscar)) {
        printf("Warning: duplicate coordinates found!\n");
        char response_poscar[10];
        printf("Do you want to remove duplicates? (yes/no): ");
        scanf("%3s", response_poscar);

        if (strcmp(response_poscar, "yes") == 0) {
            remove_duplicate_atoms(&structure, &normalized_structure_poscar);
            printf("Duplicates removed.\n");

            Structure updated_normalized_structure = create_normalized_structure(&structure);
            free(normalized_structure_poscar.atoms);
            normalized_structure_poscar = updated_normalized_structure;

            output_structure = normalized_structure_poscar;
        } else {
            printf("Duplicates not removed.\n");
        }
    }

    if (sort_option == 1) {
        qsort(output_structure.atoms, output_structure.atom_count, sizeof(Atom), compare_atoms_asc);
    } else if (sort_option == 2) {
        qsort(output_structure.atoms, output_structure.atom_count, sizeof(Atom), compare_atoms_desc);
    } else if (sort_option == 3 && custom_count > 0) {
        sort_atoms_custom(custom_order, custom_count);
    }

    char unique_elements[256][3];
    int counts[256] = {0};
    int unique_count = 0;

    for (int i = 0; i < output_structure.atom_count; i++) {
        int found = 0;
        for (int j = 0; j < unique_count; j++) {
            if (strncmp(output_structure.atoms[i].element, unique_elements[j], 2) == 0) {
                counts[j]++;
                found = 1;
                break;
            }
        }
        if (!found) {
            strcpy(unique_elements[unique_count], output_structure.atoms[i].element);
            counts[unique_count] = 1;
            unique_count++;
        }
    }

    for (int i = 0; i < unique_count; i++) {
        fprintf(file, "%s ", unique_elements[i]);
    }
    fprintf(file, "\n");

    for (int i = 0; i < unique_count; i++) {
        fprintf(file, "%d ", counts[i]);
    }
    fprintf(file, "\n");

    fprintf(file, "Direct\n");

    for (int i = 0; i < output_structure.atom_count; i++) {
        fprintf(file, "%*.*f %*.*f %*.*f\n",
                field_width, 15, output_structure.atoms[i].x,
                field_width, 15, output_structure.atoms[i].y,
                field_width, 15, output_structure.atoms[i].z);
    }

    if (output_structure.atoms != structure.atoms) {
        free(output_structure.atoms); 
    }
    free(normalized_structure_poscar.atoms);
    fclose(file);
}
